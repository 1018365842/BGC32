/*
  Sept 2013

  bgc32 Rev -

  Copyright (c) 2013 John Ihlein.  All rights reserved.

  Open Source STM32 Based Brushless Gimbal Controller Software

  Includes code and/or ideas from:

  1)AeroQuad
  2)BaseFlight
  3)CH Robotics
  4)MultiWii
  5)S.O.H. Madgwick
  6)UAVX

  Designed to run on the EvvGC Brushless Gimbal Controller Board

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

///////////////////////////////////////////////////////////////////////////////

#include "board.h"

///////////////////////////////////////////////////////////////////////////////

uint8_t firstPass[3] = { true, true, true };

float axisPID[3];
float previousAxisPID[3];

float pointingCmd[3] = { 0.0f, 0.0f, 0.0f };

///////////////////////////////////////////////////////////////////////////////
// Compute Motor Commands
///////////////////////////////////////////////////////////////////////////////

void computeMotorCommands(float dt)
{
	float cmd;

	holdIntegrators = false;

	///////////////////////////////////

	//pointingCmd[ROLL ] = rxCommand[ROLL ] * 0.00104720;  // Temporary magic number for +/- 60 degree command in radians
	//pointingCmd[PITCH] = rxCommand[PITCH] * 0.00104720;  // Temporary magic number for +/- 60 degree command in radians
	//pointingCmd[YAW  ] = 0.0;

	///////////////////////////////////

	if (eepromConfig.rollEnabled == true)
	{
    	axisPID[ROLL] = updatePID(pointingCmd[ROLL], sensors.attitude500Hz[ROLL], dt, holdIntegrators, &eepromConfig.PID[ROLL_PID]);

		if (firstPass[ROLL] == true)
		{
			previousAxisPID[ROLL] = axisPID[ROLL];
			firstPass[ROLL] = false;
		}

		cmd = rateLimit(axisPID[ROLL], previousAxisPID[ROLL], eepromConfig.rateLimit);

        previousAxisPID[ROLL] = cmd;

    	// HJI setRollMotor(cmd, eepromConfig.rollPower);
    	SetRollMotor(cmd, eepromConfig.rollPower);  // HJI
    }

    ///////////////////////////////////

    if (eepromConfig.pitchEnabled == true)
    {
    	axisPID[PITCH] = updatePID(pointingCmd[PITCH], sensors.attitude500Hz[PITCH], dt, holdIntegrators, &eepromConfig.PID[PITCH_PID]);

		if (firstPass[PITCH] == true)
		{
			previousAxisPID[PITCH] = axisPID[PITCH];
			firstPass[PITCH] = false;
		}

		cmd = rateLimit(axisPID[PITCH], previousAxisPID[PITCH], eepromConfig.rateLimit);

		previousAxisPID[PITCH] = cmd;

		// HJI setPitchMotor(cmd, eepromConfig.pitchPower);
		SetPitchMotor(cmd, eepromConfig.pitchPower);  // HJI
    }

    ///////////////////////////////////

    if (eepromConfig.yawEnabled == true)
    {
    	axisPID[YAW] = updatePID(pointingCmd[YAW], sensors.attitude500Hz[YAW], dt, holdIntegrators, &eepromConfig.PID[YAW_PID]);

    	// HJI setYawMotor(axisPID[YAW], eepromConfig.yawPower);
    	SetYawMotor(axisPID[YAW], eepromConfig.yawPower);  // HJI
    }

    ///////////////////////////////////

}

///////////////////////////////////////////////////////////////////////////////
